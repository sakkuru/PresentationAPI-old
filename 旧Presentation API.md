# Presentation API

Editor's Draft 18 March 2015

## 概要

本仕様はWebコンテンツに外部プレゼンテーションタイプのディスプレイにアクセスし、Webコンテンツを表示することを可能にするAPIを定義する。

## 本ドキュメントの状態

## 1. 導入

本セクションは非規範的である。

本仕様はプロジェクタや接続されたTVなどのセカンダリディスプレイに、webが利用できるようにすることを目的としている。有線（HDMI, DVI等）や無線技術(MiraCast, Chromecast, DLNA, AirPlay等)
で接続されているディスプレイを考慮に入れる。

限られたスクリーンサイズのデバイスは、多くの聴衆へのコンテンツ表示能力に欠ける。例えばカンファレンスルームでの同僚グループや、宅内での友人や家族など。
外部の大きなディスプレイへのコンテンツ表示は、提示されたコンテンツの認知される質やインパクトを向上させる。

本質では、本仕様はリクエストを送るページとセカンダリディスプレイに表示されるページとの間でメッセージ交換を可能にする。
どのようにメッセージが送信されるかは、さまざまな方法で接続されているディスプレイデバイスの使用を許可するため、UAに委ねられる。
例えば、ディスプレイデバイスやHDMIやMiraCastで接続されている場合は、リクエストを送信するデバイス上のUAは、同じUA上でリクエストされた提示ページを表示できる。
しかし、同じデバイス上のウィンドウで表示する代わりに、OSが提供するそれら外部ディスプレイを使うためのどんな方法でも使うことができる。
この場合、リクエストを送るページも提示するページも、リクエストを送るデバイスで動いていて、OSはプレゼンテーションディスプレイ出力を他のディスプレイデバイスに送るために使われる。
セカンドディスプレイデバイスは、本仕様やHTML5を含むコンテンツについて知る必要は無い。


代わりに、いくつかのタイプの外部ディスプレイは、それ自身でHTML5を表示できるかもしれない。
また、メッセージをコンテンツに送る決められた方法を持っているかもしれない。
この場合、リクエストを送るデバイス上のUAは、提示するページをそれ自身で表示する必要がないかもしれない。
かわりに、UAはページを表示するためのリクエクストとディスプレイデバイスによって理解される形へメッセージを変換するプロキシとして動作するだろう。

このディスプレイへ接続する方法は、ディスプレイデバイスが実装を選択するだろう、これらのメッセージタイプを送る標準プロトコルの定義により将来的に強化されるだろう。

本APIは上記の方法のいずれかでディスプレイデバイスと接続されているUAに使用されることを意図している。

### ユースケース

#### プレゼンテーション

#### ビデオ・画像共有

#### ゲーム

#### 複数スクリーンへのメディア表示

## 2. 要件

### 機能要件

* 検出・可用性
	* R1: UAは、少なくとも一つのセカンダリスクリーンが使用できるかどうかを発見する方法を提供しなければならない。

* プレゼンテーションの開始
	* R3: UAはセカンドディスプレイへコンテンツ送信を開始する方法を提供しなければならない

* プレゼンテーションの再開
	* R4: UAはセカンドディスプレイに表示されているコンテンツとともに、既存のセッションの再開が出来なければならない

* 通信
	* R5: UAは、プライマリとセカンダリページの間でコントロールチャネルを持つために、プライマリとセカンダリスクリーンの間でデータ交換を可能にしなければならない。
	* R6: UAは、自身が通信しているリモートページのUAの実行局地性について憶測を立ててはならない（例：セカンダリページはリモートUA上で動いているだろう、そのため2つのページのUAは疎結合に違いない）
* シグナリング切断
	* R7: UAは、提示ページからプライマリページへ、その逆も、切断信号を送れなければならない

### 非機能要件
* パワーセーブフレンドリー

## 3. 適合性

## 4. 用語

## 5. 例

準拠したUAで動き、ページhttp://を、プレゼン用のディスプレイでプレゼンするためのコードは次のようになる

```
code
```

セカンダリスクリーンの可用性監視は、ページがnavigator.presentationオブジェクト上のavailablechangeイベントのためのイベントリスナを追加した時に開始する。
ページがそのイベント用の最初のイベントリスなを追加した時に、すでに使用可能スクリーンがあるなら、可用性を知らせるために、UAは単一のavailablechangeイベントを合成する。

### 新規プレゼンテーションの開始、または既存のプレゼンテーションへの主導接続

"Show"ボタンの状態（初めはdisabled）はユーザにセカンダリスクリーンの可用性を知らせる。そしてボタンの状態は可能性が変更したときに更新される。
（イベントe.availableのプロパティへの実際のboolean情報の更新の原理は、リモート無線スクリーンのネットワーク検出のための電力消費最適化するための実装を許可するためである。もしこの情報がグローバルにアクセス可能なフラグによって提供されていていたら、ネットワーク検出はフラグを最新に更新し続けるために中断されることはないだろう）

"Show"ボタンのクリックにより、navigator.presentation.startSession()を呼び出す。それはUAに、ユーザからプレゼンテーションの表示用のスクリーンのリクエストを引き起こす。
url引数は表示されるコンテンツを示す。
presentationId引数（オプション）は、ページにこのプレセンテーションインスタンスの識別し、制御することを許可する。推測しにくいidのセットにより、他のページからそれに接続できる。

もしユーザが同じpresentationIdの元で、同じurlを表示している既存のプレゼンテーションのスクリーンを選択した場合、オープナーページは既存のプレゼンテーションに接続される。
もしユーザが既存のプレゼンテーションがないスクリーンや、異なるurlやpresentationIdを映しているスクリーンを選択した場合、UAは選択されたスクリーンに接続し、その上に新規プレゼンテーションウィンドウを提示し、url引数で示されるコンテンツを表示しはじめる。
その後UAはオープナーページとこの新規プレゼンテーションを接続し、オープナーページにそれとのメッセージ交換を許可する。

navigator.presentation.startSession(url, presentationId)はオープナーページにPromiseを返す。
ユーザがスクリーンを選択した時に、プレゼンテーションページは表示され、コミュニケーションチャネルは確立され、PromiseはPresentationSessionオブジェクトをresolveする。それは通信と状態操作のためのプレゼンテーションのハンドルとして動作する。
はじめに、PresentationSessionの状態は"connected"である。
この時点で、オープナーページはメッセージ送信のためセッションのpostMessage()を、メッセージ受信のためonmessageイベントハンドラを使用して、使用してプレゼンテーションページと通信ができる。
プレゼンテーションページはPresentationSessionへのアクセスを
それはオープナーページとのメッセージの送受信


もしユーザがスクリーン選択をキャンセルした場合は、startSession(url, presentationId)によって返されるPromiseは成功にならないままである。

ユーザにスクリーン選択を提示しているペンディング中のstartSessionの呼び出しがある間（ユーザはまだ許可も中止もしていない）は、成功していないPromiseを返すことにより、ブラウザは後続の同じページからのstartSession呼び出しの拒否を選択することができる。
これはブラウザが、ユーザに表示するための'queue up'リクエストを必要とするのを防ぐ。


### 既存プレゼンテーションへの自動再接続

オープナーページはユーザにスクリーン選択を促すことなく、既存のプレゼンテーション再接続することを望むかもしれない。
例えば、あるサイトは異なるページからのメディアアイテムに、同じプレゼンテーションページ上で表示されることを許可し、それぞれのページでユーザにプレゼンテーションへの再接続を促したくないと思うだろう。

自動で再接続するために、ページはjoinSession(url, presentationId)を呼ぶことができる。それは（もし存在するなら）既存のPresentationSessionを解決するPromiseを返す。それは当初startSessionに送られたように、同じpresentationIdと同じurlをプレゼンする。
リクエストを送るページは、あたかもユーザが手動でstartSessionを通して接続したかのように、プレゼンテーションとコミュニケーションをとることができる。


joinSession(url, presentationId)が呼ばれた時点で、もしブラウザがurlとpresentationIdにマッチするPresentationSessionに気づかない場合、Promiseは解決されないままであるべきである。
ブラウザが後にそのようなセッションに気づくかもしれない（例えば、そのURLを表示しているスクリーンを含むwifiネットワークへのスイッチ）。
この場合ブラウザは、ページに稼働中のセッションへの接続を許可するために、Promiseを解決するだろう。

もしブラウザが複数のマッチするセッションを知っている場合、最も最近接続されたセッションとページを接続するべきである。
もしブラウザによって確定できない場合（例えばマッチするセッションが一度も接続されたことがないなど）、Promiseは解決されないままであるべきである。

もしページがstartSession(url, presentationId) を呼び、joinSession(url, presentationId)のコール（同じurlと同じpresentationIdをもつ）の未解決のPromiseがある場合、ユーザがstartSessionに答えてスクリーンを選択し、startSessionのPromiseは解決されjoinSessionのPromiseは解決されないだろう。


### オープンクエスチョン

### リモートスクリーンの利用

オリジナルページとプレゼンテーションページ・スクリーンの間の通信の要求に対処するため、表示中のページは同じsessionオブジェクトを使用できる。
それはnavigator.presentation.sessionプロパティ（ただのnon-null）を使用して、プレゼンテーションスクリーン上のページのため、このオブジェクトにアクセスする。

```
if (navigator.presentation.session) {
  var session = navigator.presentation.session;
  // Communicate with opener page.
  session.postMessage(/*...*/);
  session.onmessage = function() {/*...*/};

  session.onstatechange = function() {
    switch (this.state) {
      case "disconnected":
        // Handle disconnection from opener page.
    }
  };
};
```

上の例のstartSession()のurl引数で示されるコンテンツがロードされたとき、プレゼンテーションスクリーン上のページはそのセッションにセットされたnavigator.presentation.sessionプロパティを持つ。
このセッションは最初の例のオブジェクトと似ている。

プレゼンテーションページはまた、statechangeイベントをlistenすることで、通信状態を監視することができる。
状態が"disconnected"に変化した時、ページはオープナーページとの通信がロストした事実を知らされる。
statechangeイベントが新しい状態"connected"とともに発火された時、通信が再確立されるだろう。

## 6. インタフェース

### NavigatorPresentation

### AvailableChangeEvent

スクリーンの可用性が変わったときに、プライマリスクリーンのNavigatorPresentationオブジェクトで発火される。

### PresentationSession

確立されたプレゼンテーションセッションを表すオブジェクト。


## 7. アルゴリズム

### スクリーンの可用性アルゴリズム

### セッション開始アルゴリズム

### セッション加入アルゴリズム

### セッション終了アルゴリズム

### プレゼンテーション初期化アルゴリズム





